#pragma once

class DeviceCom
{
public:
	DeviceCom();
	~DeviceCom();

public:
	void SetWnd(CWnd* p);

	bool Connect(DWORD ip, int port);
	void OnConnect();

	bool Start();
	void End();
	bool IsConnnected() const;

protected:
	void Notify(UINT msg, WPARAM wParam, LPARAM lParam);

	CWnd* m_pWnd;

public:
	DWORD m_dwIP;
	int m_nPort;

	SOCKET  m_sock;

	HANDLE m_hEvtConnect;
	CWinThread* m_pThrdConnect;

	deque<BYTE> m_SendBuf;
	HANDLE m_hEvtSend, m_hExitSend;
	CCriticalSection m_SendCS;
	CWinThread* m_pThrdSend;

	deque<BYTE> m_RecvBuf;
	HANDLE m_hEvtRecv, m_hExitRecv;
	CCriticalSection m_RecvCS;
	CWinThread* m_pThrdRecv;

	static UINT DoConnect(LPVOID lpParam);
	static UINT TcpSend(LPVOID lpParam);
	static UINT TcpRecv(LPVOID lpParam);
	static bool Send(SOCKET sock, WSAEVENT hEvent, BYTE* pBuf, int nBufSize, int& nOffset);

	void CleanSocket();
};


#include "pch.h"
#include "DeviceCom.h"
#include "Settings.h"
#include "UserMsg.h"


DeviceCom::DeviceCom()
{
	m_pWnd = nullptr;

	m_hEvtConnect = NULL;
	m_pThrdConnect = nullptr;

	m_hEvtSend = NULL;
	m_hExitSend = NULL;
	m_pThrdSend = nullptr;

	m_hEvtRecv = NULL;
	m_hExitRecv = NULL;
	m_pThrdRecv = nullptr;

	m_sock = INVALID_SOCKET;
}


DeviceCom::~DeviceCom()
{
	CleanSocket();
}


void DeviceCom::SetWnd(CWnd* p)
{
	m_pWnd = p;
}


bool DeviceCom::Connect(DWORD ip, int port)
{
	if (INVALID_SOCKET != m_sock)
	{
		return false;
	}

	m_dwIP = ip;
	m_nPort = port;

	m_hEvtConnect = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_pThrdConnect = AfxBeginThread(DoConnect, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
	if (nullptr == m_pThrdConnect)
	{
		return false;
	}
	m_pThrdConnect->m_bAutoDelete = FALSE;
	m_pThrdConnect->ResumeThread();

	return true;
}


void DeviceCom::OnConnect()
{
	if (nullptr == m_pThrdConnect)
	{
		return;
	}

	if (WaitForSingleObject(m_pThrdConnect->m_hThread, INFINITE) == WAIT_OBJECT_0)
	{
		delete m_pThrdConnect;
		m_pThrdConnect = nullptr;
	}
}


bool DeviceCom::Start()
{
	// send thread
	m_hEvtSend = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_hExitSend = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_pThrdSend = AfxBeginThread(TcpSend, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
	if (nullptr == m_pThrdSend)
	{
		return 0;
	}
	m_pThrdSend->m_bAutoDelete = FALSE;
	m_pThrdSend->ResumeThread();

	// receive thread
	m_hEvtRecv = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_hExitRecv = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_pThrdRecv = AfxBeginThread(TcpRecv, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
	if (nullptr == m_pThrdRecv)
	{
		return 0;
	}
	m_pThrdRecv->m_bAutoDelete = FALSE;
	m_pThrdRecv->ResumeThread();

	return true;
}


void DeviceCom::End()
{
	CleanSocket();
}


bool DeviceCom::IsConnnected() const
{
	return m_sock != INVALID_SOCKET;
}


void DeviceCom::Notify(UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (m_pWnd != nullptr && ::IsWindow(m_pWnd->m_hWnd))
	{
		m_pWnd->PostMessage(msg, wParam, lParam);
	}
}


UINT DeviceCom::DoConnect(LPVOID lpParam)
{
	DeviceCom* pCom = (DeviceCom*)lpParam;
	if (nullptr == pCom)
	{
		return 0;
	}

	SOCKET& sock = pCom->m_sock;
	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (INVALID_SOCKET == sock)
	{
		return false;
	}

	Settings ss;

	SOCKADDR_IN sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));
	sockAddr.sin_family = AF_INET;
	sockAddr.sin_addr.s_addr = htonl(ss.m_dwIP);
	sockAddr.sin_port = htons(ss.m_nPort);

	bool bConnected = false;

	// 设置为非阻塞模式
	//u_long mode = 1;
	//ioctlsocket(m_sock, FIONBIO, &mode);
	WSAEVENT hEvent = WSACreateEvent();
	if (WSAEventSelect(sock, hEvent, FD_CONNECT | FD_CLOSE) != SOCKET_ERROR)
	{
		int ret = connect(sock, (SOCKADDR*)&sockAddr, sizeof(sockAddr));
		if (ret != 0 && WSAGetLastError() == WSAEWOULDBLOCK)
		{
			DWORD cEvents = 0;
			WSAEVENT EventArray[32] = { 0 };
			EventArray[cEvents++] = hEvent;
			DWORD retval = WSAWaitForMultipleEvents(cEvents, EventArray, TRUE, 3000, FALSE);
			if (retval == WSA_WAIT_IO_COMPLETION)
			{
				bConnected = false;
			}
			else if (retval == WSA_WAIT_TIMEOUT)
			{
				bConnected = false;
			}
			else
			{
				WSANETWORKEVENTS event;
				WSAEnumNetworkEvents(sock, hEvent, &event);
				if (event.lNetworkEvents & FD_CONNECT)
				{
					if (event.iErrorCode[FD_CONNECT_BIT] == 0)
					{
						bConnected = true;
					}
					else
					{
						bConnected = false;
					}
				}
				else if (event.lNetworkEvents & FD_CLOSE)
				{
					bConnected = false;
				}
			}
		}
		else if (ret == 0)
		{
			bConnected = true;
		}
		else
		{
			bConnected = false;
		}
	}

	WSACloseEvent(hEvent);
	if (!bConnected)
	{
		closesocket(sock);
		sock = INVALID_SOCKET;
	}

	pCom->Notify(WM_CONNECT, bConnected ? 0 : 1, 0);
	return true;
}


UINT DeviceCom::TcpSend(LPVOID lpParam)
{
	DeviceCom* pCom = (DeviceCom*)lpParam;
	if (nullptr == pCom)
	{
		return 0;
	}

	HANDLE& hSend = pCom->m_hEvtSend;
	HANDLE& hExit = pCom->m_hExitSend;
	CCriticalSection& cs = pCom->m_SendCS;
	deque<BYTE>& buf = pCom->m_SendBuf;
	SOCKET& sock = pCom->m_sock;

	BYTE* pBuf = nullptr;
	int nBufSize = 0, nOffset = 0;

	WSAEVENT hEvent = WSACreateEvent();
	WSAEventSelect(sock, hEvent, FD_WRITE | FD_CLOSE);

	while (true)
	{
		HANDLE hEventArray[8] = { NULL };
		DWORD dwEventCount = 0;

		hEventArray[dwEventCount++] = hSend;
		hEventArray[dwEventCount++] = hExit;
		DWORD dwRet = WaitForMultipleObjects(dwEventCount, hEventArray, FALSE, INFINITE);
		if (dwRet == WAIT_TIMEOUT)
		{
			break;
		}
		else if (dwRet == WAIT_FAILED)
		{
			break;
		}
		else if (dwRet == WAIT_OBJECT_0)
		{
			if (nOffset == nBufSize)
			{
				cs.Lock();

				int ss = int(buf.size());
				if (ss > 0)
				{
					if (pBuf != nullptr)
					{
						delete[] pBuf;
					}
					nBufSize = ss;
					pBuf = new BYTE[nBufSize];

					for (int i = 0; i < ss; i++)
					{
						pBuf[i] = buf[0];
						buf.pop_front();
					}

					nOffset = 0;
				}

				cs.Unlock();

				ResetEvent(hSend);
			}
		}
		else if (dwRet == (WAIT_OBJECT_0 + 1))
		{
			break;
		}

		if (!Send(sock, hEvent, pBuf, nBufSize, nOffset))
		{
			pCom->Notify(WM_DISCONNECT, 0, 0);
			break;
		}

		if (nOffset < nBufSize)
		{
			DWORD cEvents = 0;
			WSAEVENT EventArray[32] = { 0 };
			EventArray[cEvents++] = hEvent;
			EventArray[cEvents++] = hExit;
			DWORD retval = WSAWaitForMultipleEvents(cEvents, EventArray, FALSE, INFINITE, FALSE);
			if (retval == WSA_WAIT_IO_COMPLETION)
			{
				pCom->Notify(WM_DISCONNECT, 0, 0);
				break;
			}
			else if (retval == WSA_WAIT_TIMEOUT)
			{
				pCom->Notify(WM_DISCONNECT, 0, 0);
				break;
			}
			else
			{
				WSANETWORKEVENTS event;
				WSAEnumNetworkEvents(sock, hEvent, &event);
				if (event.lNetworkEvents & FD_WRITE)
				{
				}
				else if (event.lNetworkEvents & FD_CLOSE)
				{
					pCom->Notify(WM_DISCONNECT, 0, 0);
					break;
				}
			}
		}
	}

	WSACloseEvent(hEvent);

	if (pBuf != nullptr && nBufSize > 0)
	{
		delete[] pBuf;
		pBuf = nullptr;
		nBufSize = 0;
	}

	return 0;
}


bool DeviceCom::Send(SOCKET sock, WSAEVENT hEvent, BYTE* pBuf, int nBufSize, int& nOffset)
{
	int nSend = send(sock, (char*)pBuf + nOffset, nBufSize - nOffset, 0);
	if (0 == nSend)
	{
		false;
	}

	if (SOCKET_ERROR == nSend)
	{
		if (WSAEWOULDBLOCK != WSAGetLastError())
		{
			return false;
		}

		return true;
	}

	nOffset += nSend;
	return true;
}


UINT DeviceCom::TcpRecv(LPVOID lpParam)
{
	DeviceCom* pCom = (DeviceCom*)lpParam;
	if (nullptr == pCom)
	{
		return 0;
	}

	HANDLE& hRecv = pCom->m_hEvtRecv;
	HANDLE& hExit = pCom->m_hExitRecv;
	CCriticalSection& cs = pCom->m_RecvCS;
	deque<BYTE>& buf = pCom->m_RecvBuf;
	SOCKET& sock = pCom->m_sock;

	const int nBufSize = 1024;
	char* pBuf = new char[nBufSize];

	WSAEVENT hEvent = WSACreateEvent();
	WSAEventSelect(sock, hEvent, FD_READ | FD_CLOSE);

	while (true)
	{
		DWORD cEvents = 0;
		WSAEVENT EventArray[32] = { 0 };
		EventArray[cEvents++] = hEvent;
		EventArray[cEvents++] = hExit;
		DWORD retval = WSAWaitForMultipleEvents(cEvents, EventArray, FALSE, INFINITE, FALSE);
		if (retval == WSA_WAIT_IO_COMPLETION)
		{
			break;
		}
		else if (retval == WSA_WAIT_TIMEOUT)
		{
			break;
		}
		else if (retval == WAIT_OBJECT_0)
		{
			WSANETWORKEVENTS event;
			WSAEnumNetworkEvents(sock, hEvent, &event);
			if (event.lNetworkEvents & FD_READ)
			{
				if (event.iErrorCode[FD_READ_BIT] == 0)
				{
					int nRead = recv(sock, pBuf, nBufSize, 0);
					if (nRead > 0)
					{
						cs.Lock();
						for (int i = 0; i < nRead; i++)
						{
							buf.push_back(pBuf[i]);
						}
						cs.Unlock();
					}
					else
					{
						pCom->Notify(WM_DISCONNECT, 0, 0);
						break;
					}
				}
			}
			else if (event.lNetworkEvents & FD_CLOSE)
			{
				pCom->Notify(WM_DISCONNECT, 0, 0);
				break;
			}
		}
		else if (retval == (WAIT_OBJECT_0 + 1))
		{
			break;
		}
	}

	WSACloseEvent(hEvent);

	if (pBuf != nullptr)
	{
		delete[] pBuf;
		pBuf = nullptr;
	}

	return 0;
}


void DeviceCom::CleanSocket()
{
	if (INVALID_SOCKET == m_sock)
	{
		return;
	}

	if (m_pThrdRecv != nullptr)
	{
		SetEvent(m_hExitRecv);
		if (WaitForSingleObject(m_pThrdRecv->m_hThread, INFINITE) == WAIT_OBJECT_0)
		{
			delete m_pThrdRecv;
			m_pThrdRecv = nullptr;
		}
	}

	if (m_pThrdSend != nullptr)
	{
		SetEvent(m_hExitSend);
		if (WaitForSingleObject(m_pThrdSend->m_hThread, INFINITE) == WAIT_OBJECT_0)
		{
			delete m_pThrdSend;
			m_pThrdSend = nullptr;
		}
	}

	closesocket(m_sock);
	m_sock = INVALID_SOCKET;
}
